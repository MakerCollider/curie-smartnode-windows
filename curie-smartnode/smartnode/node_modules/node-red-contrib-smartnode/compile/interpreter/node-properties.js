var NODE = module.exports;
NODE.QueueList = {};
NODE.Node = {'name':'nodes'};
NODE.EventStore = {};
NODE.Timer = {};
NODE.Switch = {};
NODE.Change = {};
NODE.Inject = {};
NODE.Debug = {};
NODE.StartSwitch = {'outputValue':'output'};

NODE.LED = {'digitalPin':'DPin'};
NODE.Light = {'analogPin':'APin','interval':'interval'};
NODE.Sound = {'analogPin':'APin','interval':'interval'};
NODE.Button = {'digitalPin':'DPin','funType':'funType'};
NODE.Touch = {'digitalPin':'DPin','funType':'funType'};
NODE.Relay = {'digitalPin':'DPin'};
NODE.Rotary = {'analogPin':'APin','interval':'to'};
NODE.Buzzer = {'digitalPin':'DPin'};
NODE.GroveTemperature = {'analogPin':'APin','interval':'interval'};

NODE.ADKeyboard = {'analogPin':'APin','S1from':'S1from','S1to':'S1to','S2from':'S2from','S2to':'S2to','S3from':'S3from','S3to':'S3to','S4from':'S4from','S4to':'S4to','S5from':'S5from','S5to':'S5to','interval':'interval'};
NODE.DFColor = {'S1':'S1','S2':'S2','S3':'S3','S4':'S4','OUT':'OUT'};
NODE.DFLed = {'digitalPin':'DPin'};
NODE.DFButton = {'digitalPin':'DPin','funType':'funType'};
NODE.DFTouch = {'digitalPin':'DPin','funType':'funType'};

NODE.DFBuzzer = {'digitalPin':'DPin'};
NODE.DFRotation = {'analogPin':'APin','interval':'interval'};
NODE.DFLight = {'analogPin':'APin','interval':'interval'};
NODE.DFPIRMotion = {'digitalPin':'DPin','interval':'interval'};
NODE.DFServo = {'digitalPin':'DPin'};
NODE.DFTemperature = {'analogPin':'APin','interval':'interval'};
NODE.DFSound = {'analogPin':'APin','interval':'interval'};
NODE.DFUV = {'analogPin':'APin','interval':'interval'};
NODE.DFInfraredAvoid = {'digitalPin':'DPin','interval':'interval'};
NODE.IRDistance = {'analogPin':'APin','interval':'interval'};

NODE.Neurons = {'funType':'funType'};
NODE.NeuronFormat = {'dimension':'dimension','dataLength':'dataLength'};
NODE.Accelerometer = {'interval':'interval'};
NODE.Gyro = {'interval':'interval'};

NODE.BreathLed = {'PWMPin':'PWMPin','interval':'interval'};
NODE.PWMLed = {'PWMPin':'PWMPin'};
NODE.MotorDriver = {'PWMPinA':'PWMA','digitalPinA1':'AIN1','digitalPinA2':'AIN2','PWMPinB':'PWMB','digitalPinB1':'BIN1','digitalPinB2':'BIN2','speed':'speed'};

NODE.Delay = {'interval':'interval'};
NODE.Ble = {};
NODE.SDWrite = {'filename':'filename'};


includeArray = []; //include class not duplicate
pointerArray = []; //pointer quote not duplicate
wiresArray = [];   //wires for node
scriptBat = 'Common';  //Neurons、CurieIMU、Common、CurieNeurons
operateLength = 0;
operateValueLength = 0;
exports.verifyClass = function(className) {
	for (var n in NODE) {
		if (className == n){
            return true;
		}
	}
    return false;
}
exports.includeLibrary = function(className){
    className = this.firstLowerCase(className);

    //only include onece.
    for (var i = 0; i < includeArray.length; i++) {
        if (includeArray[i] == className){
            return '';
        }
    }

    if (this.verifyClass(className)){
        includeArray.push(className);
        var classFile = className+'.h';
        var classObj = '#include <'+classFile+'>\r';
        return classObj;
    }
    else{
        return '';
    }
}
exports.includeClass = function(className){
    className = this.firstLowerCase(className);

    //only include onece.
    for (var i = 0; i < includeArray.length; i++) {
        if (includeArray[i] == className){
            return '';
        }
    }

    if (this.verifyClass(className)){
        includeArray.push(className);
        var classFile = className+'.h';
        var classObj = '#include "'+classFile+'"\r';
        return classObj;
    }
    else{
        return '';
    }
}

exports.generateInstance = function(className,objName){
    className = this.firstLowerCase(className);
    if (this.verifyClass(className)){
        var instance = '\r'+className+'\t'+objName+';';
        return instance;
    }
    else{
        return '';
    }
}

exports.generateQueueList = function(className,objName){
    className = this.firstLowerCase(className);
    if (this.verifyClass(className)){
        var instance = '\r'+className+'<Node*> '+objName+';';
        return instance;
    }
    else{
        return '';
    }
}

exports.generateSetup = function(flows){

    var fun;
    var funBegin = '\r\rvoid setup() {\r';
    var funBody = '\tSerial.begin(115200);\r';
    funBody += '\tdelay(2000);\r';
    /*
    if (scriptBat == "Common" ||  scriptBat == "CurieIMU"  ||  scriptBat == "CurieNeurons"){
        funBody += '\ttimer.setUp();\r\r';
    }*/
    funBody += '\ttimer.setUp();\r\r';

    for (var node in flows) {
        var id = flows[node].id;
        id = id.replace('.','_');
        var objName = flows[node].type+'_'+id;
        var className = flows[node].type;

        className = this.firstLowerCase(className);

        if (this.verifyClass(className)){
            //
            var is_clear = false;

            funBody += this.getNodeLogicRules(flows,flows[node]);
            funBody += this.getNodePointer(flows,flows[node]);
            
            funBody += '\t'+objName+'.setUp(';
            if (flows[node].name == ''){
                funBody += '"'+flows[node].type+'",';
            }
            else{
                funBody += '"'+flows[node].name+'",';
            }
            
            funBody += this.getLoigcNodeFunByType(flows,flows[node]);
            if (flows[node].type != "debug"){
                funBody += this.isDebug(flows,flows[node]);
            }
            
            funBody += ');\r';

            if (flows[node].type == 'switch'){
                funBody += '\tnodeArray.clear();\r';
            }
            
            for(var w in wiresArray){
                if  (wiresArray[w].name == objName && wiresArray[w].clear == 1){
                    is_clear = true;
                }
            }
            if (is_clear){
                funBody += this.getNodesPointerClear();
            }
            else{
                funBody += '\r';
            }
            
        }
    }

    funBody += '\r\tSerial.println("setUp success! start loop");\r';
              
    var funEnd = '}\r';
    fun = funBegin + funBody + funEnd; 
    return fun;
}

exports.getNodesPointerClear = function(){
    var strBody = '\t'+this.Node.name+'.clear();\r\r';
    return strBody;
}

exports.getLoigcNodeFunByType = function(flows,flowsNode){
	var strCode = '';
	var vkArr = [];
	if (flowsNode.type == 'change'){
		var rules = flowsNode.rules;
		for (var i in rules) {
			var vkObj = {};
			vkObj.key = rules[i].t+rules[i].tot;
            if(rules[i].tot == 'msg'){
               vkObj.value = rules[i].p;
            }
            if(rules[i].tot == 'str'){
                vkObj.value = rules[i].to;
            }
			
			vkArr.push(vkObj);
		}
		if (vkArr.length == 1){
	       strCode = '"'+vkArr[0].key+'","'+vkArr[0].value+'",'+this.Node.name;
		}
		return strCode;
	}
	else if (flowsNode.type == 'switch'){
        strCode = flowsNode.wires.length+',operate'+operateLength+',value'+operateValueLength+',nodeArray';
		return strCode;
	}
    else{
        if (flowsNode.type == 'Neurons'){
            strCode = this.getNodeProperty(flowsNode)+this.getNeuronsChannel(flows,flowsNode)+',';
        }
        else{
            strCode = this.getNodeProperty(flowsNode);
        }
        
        strCode += this.Node.name;
        return strCode;
    }
	return '';
}
exports.getNeuronsChannel = function(flows,curr_node){
    var channel = 0;
    if (curr_node.type == "Neurons"){
        
        for (var node in flows) {
            var fwires = flows[node].wires;
            if (fwires.length == 1){
                for (var w in fwires[0]) {
                    if (fwires[0][w] == curr_node.id){
                        if (flows[node].type != 'change' && flows[node].type != 'switch'){
                            channel++;
                        }
                    }
                    
                }
            }
            else if(fwires.length > 1){
                for (var w in fwires) {
                    if (fwires[w][0] == curr_node.id){
                        if (flows[node].type != 'change' && flows[node].type != 'switch'){
                            channel++;
                        }
                    }
                }
            }
        }
        //console.log(channel);
    }
    return channel;
}

exports.getNodePointer = function(flows,curr_node){

    var strCode = '';
    var flowsWires = curr_node.wires;
    if (flowsWires.length == 1){ //node have single  output  //switch change and so on.
        //console.log(flowsWires);
        var n = 0;
        for (var w in flowsWires[0]) {
            for (var node in flows) {
                var id = flows[node].id;
                if (flowsWires[0][w] == id){
                    if (n == 0){
                        strCode +=  this.Node.name;
                    }
                    n++;
                    id = id.replace('.','_');
                    var objName = flows[node].type+'_'+id;

                    //check
                    var className = flows[node].type;
                    className = this.firstLowerCase(className);
                    if  (this.verifyClass(className)){
                        if (curr_node.type == 'switch'){
                            strCode +=  '<<&'+objName+';\r';
                        }
                        else{
                            strCode +=  '<<&'+objName;
                        }
                    }

                    if (curr_node.type == 'switch'){
                        strCode +=  '\tnodeArray.push('+this.Node.name+');\r';
                        strCode +=  '\t'+this.Node.name+'.clear();\r\r';
                    }
                }
            }
        }

        if (strCode !=''){
            if(curr_node.type == 'switch'){
                strCode =  '\t'+strCode;
            }
            else{
                strCode =  '\t'+strCode+';\r'
            }
        }
       
    }
    else if (flowsWires.length > 1){ //node have multiple outputs //switch
        //console.log(curr_node.type);
        //console.log(flowsWires);
        for (var w in flowsWires) {
            var wires_isNull = false;
            for (var node in flows) {
                var id = flows[node].id;
                if (flowsWires[w][0] == id){
                    //console.log(flowsWires[w]);
                    wires_isNull = true;
                    id = id.replace('.','_');
                    var objName = flows[node].type+'_'+id;

                    //check
                    var className = flows[node].type;
                    className = this.firstLowerCase(className);
                    if  (this.verifyClass(className)){
                        // multiple outputs
                        if (flowsWires[w].length==1){
                            strCode +=  '\t'+this.Node.name+'<<&'+objName+';\r';
                        }

                        if (flowsWires[w].length>1){
                            strCode +=  '\t'+this.Node.name;
                            strCode += this.getNodeObjectName(flows,flowsWires[w][0],flowsWires[w]);
                        }
                    }

                    if (curr_node.type == 'switch'){
                        strCode +=  '\tnodeArray.push('+this.Node.name+');\r';
                        strCode +=  '\t'+this.Node.name+'.clear();\r\r';
                    }
                    //pointerArray.push(objName);
                }
            }

            if (wires_isNull == false){
                strCode +=  '\tnodeArray.push('+this.Node.name+');\r';
                strCode +=  '\t'+this.Node.name+'.clear();\r\r';
            }
        }
    }
    return strCode;
}

exports.getNodeObjectName = function(flows,firstWireNodeid,flowsWires){
    var strCode = '';
    for (var i in flowsWires) {
        for (var node in flows) {
            var id = flows[node].id;
            if (flowsWires[i] == id){
                id = id.replace('.','_');
                var objName = flows[node].type+'_'+id;
                strCode +=  '<<&'+objName;
                break;
            }
        }
    }
    return strCode+';\r';
    
}

exports.isDebug = function(flows,curr_node){
    var strCode = ",false";
    var flowsWires = curr_node.wires;
    if (flowsWires.length == 1){ //node have single  output  //switch change and so on.
        var n = 0;
        for (var node in flows) {
           var id = flows[node].id;
           var type = flows[node].type;
           for (var w in flowsWires[0]) {
                if (flowsWires[0][w] == id && type == "debug"){
                    strCode = ",true";
                }
           }
        }
    }
    else if (flowsWires.length > 1){ //node have multiple outputs //switch
        for (var node in flows) {
            var id = flows[node].id;
            var type = flows[node].type;
            for (var w in flowsWires) {
                if (flowsWires[w][0] == id  && type == "debug"){
                    strCode = ",true";
                }
            }
        }
    }
    return strCode;
}


exports.getNodeLogicRules = function(flows,currFlow){
    var strCode = '';
    var vkArr = [];
    if (currFlow.type == 'switch'){
        var rules = currFlow.rules;
        for (var i in rules) {
            var vkObj = {};
            vkObj.key = rules[i].t;
            vkObj.value = rules[i].v;
            vkArr.push(vkObj);
        }
        if (vkArr.length > 0){
            if (operateLength == 0 && operateValueLength == 0){
                strCode = '\tQueueList<QueueList<Node*>>nodeArray;\r';
            }

            strCode += '\t'+this.getRulesCode('key',vkArr)+'\r';
            strCode += '\t'+this.getRulesCode('value',vkArr)+'\r\r';
        }
    }
    return strCode;
}

exports.getRulesCode = function(type,rules){
	var tempCode = '';
    var tempCode2 = '';
	var sChar = '{';
	var eChar = '};';
	for (var i in rules) {
		if (i == 0){
			if (type =='key'){
				tempCode += '"'+rules[i].key+'"';
			}
           	if (type =='value'){
                if(rules[i].value == ''){
                   rules[i].value = -1;
                }
				tempCode += rules[i].value;
			}
		}
		else{
			if (type =='key'){
				tempCode += ',"'+rules[i].key+'"';
			}
           	if (type =='value'){
                if(rules[i].value == ''){
                   rules[i].value = -1;
                }
				tempCode += ','+rules[i].value;
			}
		}
		
	}
    tempCode2 = tempCode+';';
	tempCode = sChar+tempCode+eChar;
    
    if (type =='key'){
        operateLength++;
        strCode = 'String operate'+operateLength+'['+rules.length+'] = '+tempCode;
        
    }
    
    if (type =='value'){
        operateValueLength++;
        strCode = 'int16_t value'+operateValueLength+'['+rules.length+'] = '+tempCode;
        
    }

	return strCode;
}

exports.getNodeProperty = function(node){
    var strPros = '';
    for (n in node) {
        if (n == 'type' && node[n] == 'LED'){
            return this.getCNodeProperty(node,this.LED);
        }
        if (n == 'type' && node[n] == 'Light'){
            return this.getCNodeProperty(node,this.Light);
        }
        if (n == 'type' && node[n] == 'Sound'){
            return this.getCNodeProperty(node,this.Sound);
        }
        if (n == 'type' && node[n] == 'Button'){
            return this.getCNodeProperty(node,this.Button);
        }
        if (n == 'type' && node[n] == 'Relay'){
            return this.getCNodeProperty(node,this.Relay);
        }
        if (n == 'type' && node[n] == 'Rotary'){
            return this.getCNodeProperty(node,this.Rotary);
        }
        if (n == 'type' && node[n] == 'Buzzer'){
            return this.getCNodeProperty(node,this.Buzzer);
        }
        if (n == 'type' && node[n] == 'Touch'){
            return this.getCNodeProperty(node,this.Touch);
        }        
        if (n == 'type' && node[n] == 'GroveTemperature'){
            return this.getCNodeProperty(node,this.GroveTemperature);
        }
        if (n == 'type' && node[n] == 'ADKeyboard'){
            return this.getCNodeProperty(node,this.ADKeyboard);
        }
        if (n == 'type' && node[n] == 'DFColor'){
            return this.getCNodeProperty(node,this.DFColor);
        }
        if (n == 'type' && node[n] == 'DFLed'){
            return this.getCNodeProperty(node,this.DFLed);
        }
        if (n == 'type' && node[n] == 'DFButton'){
            return this.getCNodeProperty(node,this.DFButton);
        }
        if (n == 'type' && node[n] == 'DFTouch'){
            return this.getCNodeProperty(node,this.DFTouch);
        }
        if (n == 'type' && node[n] == 'DFBuzzer'){
            return this.getCNodeProperty(node,this.DFBuzzer);
        }
        if (n == 'type' && node[n] == 'DFRotation'){
            return this.getCNodeProperty(node,this.DFRotation);
        }
        if (n == 'type' && node[n] == 'DFLight'){
            return this.getCNodeProperty(node,this.DFLight);
        }
        if (n == 'type' && node[n] == 'DFServo'){
            return this.getCNodeProperty(node,this.DFServo);
        }
        if (n == 'type' && node[n] == 'DFPIRMotion'){
            return this.getCNodeProperty(node,this.DFPIRMotion);
        }        
        if (n == 'type' && node[n] == 'DFUV'){
            return this.getCNodeProperty(node,this.DFUV);
        }
        if (n == 'type' && node[n] == 'DFInfraredAvoid'){
            return this.getCNodeProperty(node,this.DFInfraredAvoid);
        }
        
        if (n == 'type' && node[n] == 'DFTemperature'){
            return this.getCNodeProperty(node,this.DFTemperature);
        }
        if (n == 'type' && node[n] == 'DFSound'){
            return this.getCNodeProperty(node,this.DFSound);
        }
        
        if (n == 'type' && node[n] == 'Accelerometer'){
            return this.getCNodeProperty(node,this.Accelerometer);
        }
        if (n == 'type' && node[n] == 'Gyro'){
            return this.getCNodeProperty(node,this.Gyro);
        }
        
        if (n == 'type' && node[n] == 'Neurons'){
            return this.getCNodeProperty(node,this.Neurons);
        }
        if (n == 'type' && node[n] == 'NeuronFormat'){
            return this.getCNodeProperty(node,this.NeuronFormat);
        }
        if (n == 'type' && node[n] == 'BreathLed'){
            return this.getCNodeProperty(node,this.BreathLed);
        }

        if (n == 'type' && node[n] == 'PWMLed'){
            return this.getCNodeProperty(node,this.PWMLed);
        } 
        if (n == 'type' && node[n] == 'MotorDriver'){
            return this.getCNodeProperty(node,this.MotorDriver);
        } 
        if (n == 'type' && node[n] == 'IRDistance'){
            return this.getCNodeProperty(node,this.IRDistance);
        }
        if (n == 'type' && node[n] == 'Delay'){
            return this.getCNodeProperty(node,this.Delay);
        }
        if (n == 'type' && node[n] == 'StartSwitch'){
            return this.getCNodeProperty(node,this.StartSwitch);
        }   
        if (n == 'type' && node[n] == 'SDWrite'){
            return this.getCNodeProperty(node,this.SDWrite,'string');
        }  
          
    }
    return strPros;
}

exports.getCNodeProperty = function(node,c_node,dataType){
    var strPros = '';
    var i = 0;
    for (var p in c_node) {
        if (node.hasOwnProperty(p) == true){
            if (i == 0){
                if (dataType == 'string'){
                    strPros = '"'+node[p]+'"'+',';
                }
                else{
                    strPros = node[p]+',';
                }
                
            }
            else{
                if (dataType == 'string'){
                    strPros += '"'+node[p]+'"'+',';
                }
                else{
                    strPros += node[p]+',';
                }
                
            }
            i++;
        }
    }
    return strPros;
}
exports.generateLoop = function(){
    var fun;
    var funBegin = '\rvoid loop() {\r';
    var funBody = '\teventStore.exec();\r';
    var funEnd = '}\r';
    fun = funBegin + funBody + funEnd;
    return fun;
}

exports.generateSerialEvent = function(injectClassName){
    var variable_1 = '\rString injectString = "";\r';
    var variable_2 = 'String injectDigital = "";\r';
    var variable_3 = 'unsigned char msgCount=0;\r';
    
    var fun;
    var funBegin = '\rvoid serialEvent() {\r';
    var funBody = '\tint16_t msg[30]={0};\r';
    funBody += '\twhile (Serial.available()) {\r';
    funBody += '\t\tchar inChar = (char)Serial.read();\r';
    funBody += '\t\tif(isDigit(inChar)){\r';
    funBody += '\t\t\tinjectDigital += inChar;\r';
    funBody += '\t\t}\r';
    funBody += '\t\telse{\r';
    funBody += '\t\t\tinjectString += inChar;\r';
    funBody += '\t\t\tmsg[msgCount] = injectDigital.toInt();\r';
    funBody += '\t\t\tinjectDigital = "";\r';
    funBody += '\t\t\tmsgCount++;\r';
    funBody += '\t\t}\r';
    funBody += '\t}\r';

    funBody += '\tmsg[msgCount] = injectDigital.toInt();\r';
    funBody += '\tQueueList<Node*> node;\r';
    funBody += '\tnode<<&'+injectClassName+';\r';
    funBody += '\tuint8_t msgLen = msgCount+1;\r';
    funBody += '\teventStore.addEvent(node,input,"Serial",msg,msgLen);\r';
    funBody += '\tmsg[0] = 0;\r';
    funBody += '\tmsgCount = 0;\r';
    funBody += '\tinjectDigital = "";\r';
    funBody += '\tinjectString = "";\r';
    var funEnd = '}\r';
    fun = funBegin + funBody + funEnd;
    return variable_1+variable_2+variable_3+fun;
}

exports.firstLowerCase = function(str){
    var reg = /\b(\w)|\s(\w)/g;
    //str = str.toLowerCase();
    return str.replace(reg,function(m){return m.toUpperCase()})
}
