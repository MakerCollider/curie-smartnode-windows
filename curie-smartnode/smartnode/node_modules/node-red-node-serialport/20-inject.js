/**
 * Copyright 2013, 2016 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

module.exports = function(RED) {
    "use strict";
    var cron = require("cron");

    var settings = RED.settings;
    var events = require("events");
    var serialp = require("serialport");
    var bufMaxSize = 32768;  // Max serial buffer size, for inputs...

    function SerialPortNode(n) {
        RED.nodes.createNode(this,n);
        this.serialport = n.serialport;
        this.newline = n.newline;
        this.addchar = n.addchar || "false";
        this.serialbaud = parseInt(n.serialbaud) || 57600;
        this.databits = parseInt(n.databits) || 8;
        this.parity = n.parity || "none";
        this.stopbits = parseInt(n.stopbits) || 1;
        this.bin = n.bin || "false";
        this.out = n.out || "char";
    }
    RED.nodes.registerType("serial-port",SerialPortNode);

    function InjectNode(n) {
        RED.nodes.createNode(this,n);
        this.topic = n.topic;
        this.payload = n.payload;
        this.payloadType = n.payloadType;
        this.repeat = n.repeat;
        this.crontab = n.crontab;
        this.once = n.once;
        //var node = this;
        this.interval_id = null;
        this.cronjob = null;

        this.serial = n.serial;
        this.serialConfig = RED.nodes.getNode(this.serial);
        this.status({fill:"grey",shape:"dot",text:"node-red:common.status.not-connected"});
        
        var objInject = {"id":this.id,"status":"init"};
        var is_exist = false;
        for (var i in globalArrayInjects) {
            if(globalArrayInjects[i].id == this.id){
               is_exist = true;
            }
        }
        
        if (is_exist == false){
            globalArrayInjects.push(objInject);
        }


        var node = this;

        if (globalArrayInjects.length>maxConnected){
            node.status({fill:"red",shape:"dot",text:"node-red:common.status.connect-max-limit"});
            return;
        }

        var injectConnectCount = 0;
        node.interval_id = setInterval(function() {
            for (var i in globalArrayInjects) {
                if (node.id == globalArrayInjects[i].id && globalArrayInjects[i].status == "finished"){
                    if (injectConnectCount == 0){
                        for (var j in globalSerialConnects) {
                            if (node.id == globalSerialConnects[j]){
                                injectConnectCount = 1;
                                break;
                            }
                        }
                        if (injectConnectCount ==0){
                            initInject();
                        }
                    } 
                }
                if (node.id == globalArrayInjects[i].id && globalArrayInjects[i].status == "opened"){
                    node.status({fill:"green",shape:"dot",text:"node-red:common.status.connected"});
                    if (node.interval_id != null) {
                        clearInterval(node.interval_id);
                    }
                }
            }
        }, settings.serialWaitReconnectTime);
        
        function initInject(){  
            if (node.serialConfig) {
                
                node.status({fill:"yellow",shape:"dot",text:"node-red:common.status.connecting"});
                node.port = serialPool.get(node.id,node.serialConfig.serialport,
                    node.serialConfig.serialbaud,
                    node.serialConfig.databits,
                    node.serialConfig.parity,
                    node.serialConfig.stopbits,
                    node.serialConfig.newline);
                node.addCh = "";
                if (node.serialConfig.addchar == "true" || node.serialConfig.addchar === true) {
                    node.addCh = node.serialConfig.newline.replace("\\n","\n").replace("\\r","\r").replace("\\t","\t").replace("\\e","\e").replace("\\f","\f").replace("\\0","\0"); // jshint ignore:line
                }

                node.on("input",function(msg) {
                     try {
                        msg = {topic:node.topic};
                        if ( (node.payloadType == null && node.payload === "") || node.payloadType === "date") {
                            msg.payload = Date.now();
                        } else if (node.payloadType == null) {
                            msg.payload = node.payload;
                        } else if (node.payloadType == 'none') {
                            msg.payload = "";
                        } else {
                            msg.payload = RED.util.evaluateNodeProperty(node.payload,node.payloadType,node,msg);
                        }
                        node.send(msg);
                        //----------------------
                        if (msg.hasOwnProperty("payload")) {
                            var payload = msg.payload;
                            if (!Buffer.isBuffer(payload)) {
                                if (typeof payload === "object") {
                                    payload = JSON.stringify(payload);
                                } else {
                                    payload = payload.toString();
                                }
                                payload += node.addCh;
                            } else if (node.addCh !== "") {
                                payload = Buffer.concat([payload,new Buffer(node.addCh)]);
                            }
                            node.port.write(payload,function(err,res) {
                                if (err) {
                                    var errmsg = err.toString().replace("Serialport","Serialport "+node.port.serial.path);
                                    node.error(errmsg,msg);
                                }
                            });
                        }
                        //----------------------
                        msg = null;
                    } catch(err) {
                        node.error(err,msg);
                    }
                });
                node.port.on('ready', function() {
                    node.status({fill:"green",shape:"dot",text:"node-red:common.status.connected"});
                    for (var i in globalArrayInjects) {
                        if (node.id == globalArrayInjects[i].id){
                            globalArrayInjects[i].status = "opened";
                        }
                    }
                    if (node.interval_id != null) {
                        clearInterval(node.interval_id);
                    }
                    
                });
                node.port.on('closed', function() {
                    node.status({fill:"red",shape:"ring",text:"node-red:common.status.not-connected"});
                    for (var i in globalArrayInjects) {
                        if (node.id == globalArrayInjects[i].id){
                            globalArrayInjects[i].status = "closed";
                        }
                    }
                    
                });
            } else {
                node.error(RED._("serial.errors.missing-conf"));
            }

            node.on("close", function(done) {

                for (var i in globalArrayInjects) {
                    if (node.id == globalArrayInjects[i].id){
                        globalArrayInjects.splice(i,1);
                    }
                }

                if (node.serialConfig) {
                    serialPool.close(node.id,node.serialConfig.serialport,done);
                } else {
                    done();
                }
                
                if (node.interval_id != null) {
                    clearInterval(node.interval_id);
                    if (RED.settings.verbose) { node.log(RED._("inject.stopped")); }
                } else if (node.cronjob != null) {
                    node.cronjob.stop();
                    if (RED.settings.verbose) { node.log(RED._("inject.stopped")); }
                    delete node.cronjob;
                }
            });

        }
    }

    RED.nodes.registerType("inject",InjectNode);


    RED.httpAdmin.post("/inject/:id", RED.auth.needsPermission("inject.write"), function(req,res) {
        var node = RED.nodes.getNode(req.params.id);
        if (node != null) {
            try {
                node.receive();
                res.sendStatus(200);
            } catch(err) {
                res.sendStatus(500);
                node.error(RED._("inject.failed",{error:err.toString()}));
            }
        } else {
            res.sendStatus(404);
        }
    });

    //---------------------------------------debug-------------------------------------
    var util = require("util");
    var debuglength = RED.settings.debugMaxLength||1000;
    var useColors = false;

    function DebugNode(n) {
        RED.nodes.createNode(this,n);
        this.name = n.name;
        this.complete = (n.complete||"payload").toString();

        if (this.complete === "false") {
            this.complete = "payload";
        }
        
        this.interval_id = null;
        this.console = n.console;
        this.active = (n.active === null || typeof n.active === "undefined") || n.active;
        //----------------------------
        this.serial = n.serial;

        this.serialConfig = RED.nodes.getNode(this.serial);

        var node = this;

        node.status({fill:"grey",shape:"dot",text:"node-red:common.status.not-connected"});

        var objInject = {"id":this.id,"status":"init"};

        var is_exist = false;
        for (var i in globalArrayInjects) {
            if(globalArrayInjects[i].id == this.id){
               is_exist = true;
            }
        }
        
        if (is_exist == false){
            globalArrayInjects.push(objInject);
        }

        if (globalArrayInjects.length>maxConnected){
            node.status({fill:"red",shape:"dot",text:"node-red:common.status.connect-max-limit"});
            return;
        }

        var debugConnectCount = 0;
        node.interval_id = setInterval(function() {
            for (var i in globalArrayInjects) {
                if (node.id == globalArrayInjects[i].id && globalArrayInjects[i].status == "finished"){
                	if(debugConnectCount == 0){
                        for (var j in globalSerialConnects) {
                            if (node.id == globalSerialConnects[j]){
                                debugConnectCount = 1;
                                break;
                            }
                        }
                        if (debugConnectCount ==0){
                            initDebug();
                        }
                	}
                }

                if (node.id == globalArrayInjects[i].id && globalArrayInjects[i].status == "opened"){
                    node.status({fill:"green",shape:"dot",text:"node-red:common.status.connected"});
                    if (node.interval_id != null) {
                        clearInterval(node.interval_id);
                    }
                }
            }
        }, settings.serialWaitReconnectTime);
    
        function initDebug(){ 
            if (node.serialConfig) {
                node.status({fill:"yellow",shape:"dot",text:"node-red:common.status.connecting"});
                node.tout = null;
                var buf;
                if (node.serialConfig.out != "count") { buf = new Buffer(bufMaxSize); }
                else { buf = new Buffer(Number(node.serialConfig.newline)); }
                var i = 0;
                
                node.port = serialPool.get(node.id,node.serialConfig.serialport,
                    node.serialConfig.serialbaud,
                    node.serialConfig.databits,
                    node.serialConfig.parity,
                    node.serialConfig.stopbits,
                    node.serialConfig.newline
                );

                var splitc;
                if (node.serialConfig.newline.substr(0,2) == "0x") {
                    splitc = new Buffer([parseInt(node.serialConfig.newline)]);
                } else {
                    splitc = new Buffer(node.serialConfig.newline.replace("\\n","\n").replace("\\r","\r").replace("\\t","\t").replace("\\e","\e").replace("\\f","\f").replace("\\0","\0")); // jshint ignore:line
                }

                node.port.on('data', function(msg) {
                    // single char buffer
                    if ((node.serialConfig.newline === 0)||(node.serialConfig.newline === "")) {
                        if (node.serialConfig.bin !== "bin") { 
                        	node.send({"payload": String.fromCharCode(msg)}); 
                        }
                        else { 
                            //node.send({"payload": new Buffer([msg])}); 
                            if (node.active) {
                                //sendDebug({"payload": new Buffer([msg])});
                                inputMsg(node,{"payload": new Buffer([msg])});
                            }
                        }
                    }
                    else {
                        // do the timer thing
                        if (node.serialConfig.out === "time") {
                            if (node.tout) {
                                i += 1;
                                buf[i] = msg;
                            }
                            else {
                                node.tout = setTimeout(function () {
                                    node.tout = null;
                                    var m = new Buffer(i+1);
                                    buf.copy(m,0,0,i+1);
                                    if (node.serialConfig.bin !== "bin") { m = m.toString(); }
                                    node.send({"payload":m});
                                    if (node.active) {
                                        //sendDebug({"payload": m});
                                        inputMsg(node,{"payload": m});
                                    }
                                    m = null;
                                }, node.serialConfig.newline);
                                i = 0;
                                buf[0] = msg;
                            }
                        }
                        // count bytes into a buffer...
                        else if (node.serialConfig.out === "count") {
                            buf[i] = msg;
                            i += 1;
                            if ( i >= parseInt(node.serialConfig.newline)) {
                                var m = new Buffer(i);
                                buf.copy(m,0,0,i);
                                if (node.serialConfig.bin !== "bin") { m = m.toString(); }
                                //node.send({"payload":m});
                                if (node.active) {
                                    //sendDebug({"payload": m});
                                    inputMsg(node,{"payload": m});
                                }
                                m = null;
                                i = 0;
                            }
                        }
                        // look to match char...
                        else if (node.serialConfig.out === "char") {
                            buf[i] = msg;
                            i += 1;
                            if ((msg === splitc[0]) || (i === bufMaxSize)) {
                                var n = new Buffer(i);
                                buf.copy(n,0,0,i);
                                if (node.serialConfig.bin !== "bin") { n = n.toString(); }
                                //node.send({"payload":n});
                                if (node.active) {
                                    //sendDebug({"payload": n});
                                    inputMsg(node,{"payload": n});
                                }
                                n = null;
                                i = 0;
                            }
                        }
                    }
                });
                node.port.on('ready', function() {
                    node.status({fill:"green",shape:"dot",text:"node-red:common.status.connected"});
                    for (var i in globalArrayInjects) {
                        if (node.id == globalArrayInjects[i].id){
                            globalArrayInjects[i].status = "opened";
                        }
                    }
                    if (node.interval_id != null) {
                        clearInterval(node.interval_id);
                    }
                });
                node.port.on('closed', function() {
                    node.status({fill:"red",shape:"ring",text:"node-red:common.status.not-connected"});
                    for (var i in globalArrayInjects) {
                        if (node.id == globalArrayInjects[i].id){
                            globalArrayInjects[i].status = "closed";
                        }
                    }
                });
            } else {
                node.error(RED._("serial.errors.missing-conf"));
            }

            node.on("close", function(done) {
                for (var i in globalArrayInjects) {
                    if (node.id == globalArrayInjects[i].id){
                        globalArrayInjects.splice(i,1);
                    }
                }

                if (node.serialConfig) {
                    serialPool.close(node.id,node.serialConfig.serialport,done);
                } else {
                    done();
                }

                if (node.interval_id != null) {
                    clearInterval(node.interval_id);
                }
            });
        }
        //-------------------------
    }

    RED.nodes.registerType("debug",DebugNode);

    function inputMsg(_node,msg){

            if (_node.complete === "true") {
            // debug complete msg object
                if (_node.console === "true") {
                    _node.log("\n"+util.inspect(msg, {colors:useColors, depth:10}));
                }
                if (_node.active) {
                    sendDebug({id:_node.id,name:_node.name,topic:msg.topic,msg:msg,_path:msg._path});
                }
            } else {
            // debug user defined msg property
                var property = "payload";
                var output = msg[property];
                if (_node.complete !== "false" && typeof _node.complete !== "undefined") {
                    property = _node.complete;
                    var propertyParts = property.split(".");
                    try {
                        output = propertyParts.reduce(function (obj, i) {
                            return obj[i];
                        }, msg);
                    } catch (err) {
                        output = undefined;
                    }
                }
                if (_node.console === "true") {
                    if (typeof output === "string") {
                        _node.log((output.indexOf("\n") !== -1 ? "\n" : "") + output);
                    } else if (typeof output === "object") {
                        _node.log("\n"+util.inspect(output, {colors:useColors, depth:10}));
                    } else {
                        _node.log(util.inspect(output, {colors:useColors}));
                    }
                }
                if (_node.active) {
                    sendDebug({id:_node.id,name:_node.name,topic:msg.topic,property:property,msg:output,_path:msg._path});
                }
            }
            
    }
    function sendDebug(msg) {
        if (msg.msg instanceof Error) {
            msg.format = "error";
            msg.msg = msg.msg.toString();
        } else if (msg.msg instanceof Buffer) {
            msg.format = "buffer ["+msg.msg.length+"]";
            msg.msg = msg.msg.toString('hex');
        } else if (msg.msg && typeof msg.msg === 'object') {
            var seen = [];
            msg.format = msg.msg.constructor.name || "Object";
            var isArray = util.isArray(msg.msg);
            if (isArray) {
                msg.format = "array ["+msg.msg.length+"]";
            }
            if (isArray || (msg.format === "Object")) {
                msg.msg = JSON.stringify(msg.msg, function(key, value) {
                    if (typeof value === 'object' && value !== null) {
                        if (seen.indexOf(value) !== -1) { return "[circular]"; }
                        seen.push(value);
                    }
                    return value;
                }," ");
            } else {
                try { msg.msg = msg.msg.toString(); }
                catch(e) { msg.msg = "[Type not printable]"; }
            }
            seen = null;
        } else if (typeof msg.msg === "boolean") {
            msg.format = "boolean";
            msg.msg = msg.msg.toString();
        } else if (typeof msg.msg === "number") {
            msg.format = "number";
            msg.msg = msg.msg.toString();
        } else if (msg.msg === 0) {
            msg.format = "number";
            msg.msg = "0";
        } else if (msg.msg === null || typeof msg.msg === "undefined") {
            msg.format = (msg.msg === null)?"null":"undefined";
            msg.msg = "(undefined)";
        } else {
            msg.format = "string ["+msg.msg.length+"]";
            msg.msg = msg.msg;
        }

        if (msg.msg.length > debuglength) {
            msg.msg = msg.msg.substr(0,debuglength) +" ....";
        }
        RED.comms.publish("debug",msg);
    }

    DebugNode.logHandler = new events.EventEmitter();
    DebugNode.logHandler.on("log",function(msg) {
        if (msg.level === RED.log.WARN || msg.level === RED.log.ERROR) {
            sendDebug(msg);
        }
    });
    RED.log.addHandler(DebugNode.logHandler);

    RED.httpAdmin.post("/debug/:id/:state", RED.auth.needsPermission("debug.write"), function(req,res) {
        var node = RED.nodes.getNode(req.params.id);
        var state = req.params.state;
        if (node !== null && typeof node !== "undefined" ) {
            if (state === "enable") {
                node.active = true;
                res.sendStatus(200);
            } else if (state === "disable") {
                node.active = false;
                res.sendStatus(201);
            } else {
                res.sendStatus(404);
            }
        } else {
            res.sendStatus(404);
        }
    });
    //-------------------------------------serial--------------------------------------
    var serialPool = (function() {
        var connections = {};
        return {
            get:function(nodeid,port,baud,databits,parity,stopbits,newline,callback) {
                var id = port;
                 
                if (!connections[id]) {
                    globalSerialConnects.push(nodeid);

                    connections[id] = (function() {
                        var obj = {
                            _emitter: new events.EventEmitter(),
                            serial: null,
                            _closing: false,
                            tout: null,
                            on: function(a,b) { this._emitter.on(a,b); },
                            close: function(cb) { this.serial.close(cb); },
                            write: function(m,cb) { this.serial.write(m,cb); },
                        }
                        //newline = newline.replace("\\n","\n").replace("\\r","\r");
                        var olderr = "";
                        var setupSerial = function() {
                            obj.serial = new serialp.SerialPort(port,{
                                baudrate: baud,
                                databits: databits,
                                parity: parity,
                                stopbits: stopbits,
                                parser: serialp.parsers.raw
                            },true, function(err, results) {
                                if (err) {
                                    if (err.toString() !== olderr) {
                                        olderr = err.toString();
                                        //RED.log.error(RED._("serial.errors.error",{port:port,error:olderr}));
                                    }
                                    obj.tout = setTimeout(function() {
                                        setupSerial();
                                    }, settings.serialReconnectTime);
                                }
                            });
                            obj.serial.on('error', function(err) {
                               // RED.log.error(RED._("serial.errors.error",{port:port,error:err.toString()}));
                                obj._emitter.emit('closed');
                                obj.tout = setTimeout(function() {
                                    setupSerial();
                                }, settings.serialReconnectTime);
                            });
                            obj.serial.on('close', function() {
                                if (!obj._closing) {
                                    //RED.log.error(RED._("serial.errors.unexpected-close",{port:port}));
                                    obj._emitter.emit('closed');
                                    obj.tout = setTimeout(function() {
                                        setupSerial();
                                    }, settings.serialReconnectTime);
                                }
                            });
                            obj.serial.on('open',function() {
                                olderr = "";
                                RED.log.info(RED._("serial.onopen",{port:port,baud:baud,config: databits+""+parity.charAt(0).toUpperCase()+stopbits}));
                                if (obj.tout) { clearTimeout(obj.tout); }
                                //obj.serial.flush();
                                obj._emitter.emit('ready');
                            });
                            obj.serial.on('data',function(d) {
                                for (var z=0; z<d.length; z++) {
                                    obj._emitter.emit('data',d[z]);
                                }
                            });
                            obj.serial.on("disconnect",function() {
                                RED.log.error(RED._("serial.errors.disconnected",{port:port}));
                            });
                        }
                        setupSerial();
                        return obj;
                    }());
                }
                
                return connections[id];
            },
            close: function(nodeid,port,done) {
                if (connections[port]) {
                    if (connections[port].tout != null) {
                        clearTimeout(connections[port].tout);
                    }
                    connections[port]._closing = true;
                    try {
                        connections[port].close(function() {
                            //RED.log.info(RED._("serial.errors.closed",{port:port}));
                            done();

                            for (var j in globalSerialConnects) {
                                if (nodeid == globalSerialConnects[j]){
                                    globalSerialConnects.splice(j,1);
                                }
                            }
                        });
                    }
                    catch(err) { }
                    delete connections[port];
                } else {
                    done();
                }
            }
        }
    }());

    RED.httpAdmin.get("/serialports", RED.auth.needsPermission('serial.read'), function(req,res) {
        serialp.list(function (err, ports) {
            res.json(ports);
        });
    });
}
